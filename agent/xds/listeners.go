package xds

import (
	"errors"
	"fmt"

	"github.com/envoyproxy/go-control-plane/envoy/api/v2"
	"github.com/envoyproxy/go-control-plane/envoy/api/v2/auth"
	"github.com/envoyproxy/go-control-plane/envoy/api/v2/core"
	"github.com/envoyproxy/go-control-plane/envoy/api/v2/listener"
	extAuthz "github.com/envoyproxy/go-control-plane/envoy/config/filter/network/ext_authz/v2"
	tcp "github.com/envoyproxy/go-control-plane/envoy/config/filter/network/tcp_proxy/v2"
	"github.com/envoyproxy/go-control-plane/pkg/util"
	"github.com/gogo/protobuf/jsonpb"
	"github.com/gogo/protobuf/proto"
	"github.com/gogo/protobuf/types"

	"github.com/hashicorp/consul/agent/proxycfg"
	"github.com/hashicorp/consul/agent/structs"
)

// listenersFromSnapshot returns the xDS API reprepsentation of the "listeners"
// in the snapshot.
func listenersFromSnapshot(cfgSnap *proxycfg.ConfigSnapshot, token string) ([]proto.Message, error) {
	if cfgSnap == nil {
		return nil, errors.New("nil config given")
	}

	// One listener for each upstream plus the public one
	resources := make([]proto.Message, len(cfgSnap.Proxy.Upstreams)+1)

	// Configure public listener
	var err error
	resources[0], err = makePublicListener(cfgSnap, token)
	if err != nil {
		return nil, err
	}
	for i, u := range cfgSnap.Proxy.Upstreams {
		resources[i+1], err = makeUpstreamListener(&u)
		if err != nil {
			return nil, err
		}
	}
	return resources, nil
}

// makeListener returns a listener with name and bind details set. Filters must
// be added before it's useful.
//
// Note on names: Envoy listeners attempt gracefull transitions of connections
// when their config changes but that means they can't have their bind address
// or port changed in a running instance. Since our users might choose to change
// a bind address or port for the public or upstream listeners, we need to
// encode those into the unique name for the listener such that if the user
// changes them, we actually create a whole new listener on the new address and
// port. Envoy should take care of closing the old one once it sees it's no
// longer in the config.
func makeListener(name, addr string, port int) *v2.Listener {
	return &v2.Listener{
		Name:    fmt.Sprintf("%s:%s:%d", name, addr, port),
		Address: makeAddress(addr, port),
	}
}

// makeListenerFromUserConfig returns the listener config decoded from an
// arbitrary proto3 json format string or an error if it's invalid.
//
// For now we only support embedding in JSON strings because of the hcl parsing
// pain (see config.go comment above call to patchSliceOfMaps). Until we
// refactor config parser a _lot_ user's opaque config that contains arrays will
// be mangled. We could actually fix that up in mapstructure which knows the
// type of the target so could resolve the slices to singletons unambiguously
// and it would work for us here... but we still have the problem that the
// config would render incorrectly in general in our HTTP API responses so we
// really need to fix it "properly".
//
// When we do that we can support just nesting the config directly into the
// JSON/hcl naturally but this is a stop-gap that gets us an escape hatch
// immediately. It's also probably not a bad thing to support long-term since
// any config generated by other systems will likely be in canonical protobuf
// from rather than our slight variant in JSON/hcl.
func makeListenerFromUserConfig(configJSON string) (proto.Message, error) {
	// Try to decode directly as a types.Any and return that (with nested types
	// already proto serialized).
	var any types.Any
	err := jsonpb.UnmarshalString(configJSON, &any)
	if err == nil {
		return &any, nil
	}
	// Failed, try again decoding as a straight listener (i.e. no @type annotation
	// in the JSON)
	var l v2.Listener
	err = jsonpb.UnmarshalString(configJSON, &l)
	if err != nil {
		return nil, err
	}
	return &l, nil
}

func makePublicListener(cfgSnap *proxycfg.ConfigSnapshot, token string) (proto.Message, error) {
	if listenerJSONRaw, ok := cfgSnap.Proxy.Config["envoy_public_listener_json"]; ok {
		if listenerJSON, ok := listenerJSONRaw.(string); ok {
			return makeListenerFromUserConfig(listenerJSON)
		}
	}
	addr := cfgSnap.Address
	if addr == "" {
		addr = "0.0.0.0"
	}
	l := makeListener("public_listener", addr, cfgSnap.Port)
	l.FilterChains = []listener.FilterChain{
		{
			Filters: []listener.Filter{
				makeExtAuthFilter(token),
				makeTCPProxyFilter("public_listener", LocalAppClusterName),
			},
			TlsContext: &auth.DownstreamTlsContext{
				CommonTlsContext:         makeCommonTLSContext(cfgSnap),
				RequireClientCertificate: &types.BoolValue{Value: true},
			},
		},
	}
	return l, nil
}

func makeUpstreamListener(u *structs.Upstream) (proto.Message, error) {
	if listenerJSONRaw, ok := u.Config["envoy_listener_json"]; ok {
		if listenerJSON, ok := listenerJSONRaw.(string); ok {
			return makeListenerFromUserConfig(listenerJSON)
		}
	}
	addr := u.LocalBindAddress
	if addr == "" {
		addr = "127.0.0.1"
	}
	l := makeListener(u.Identifier(), addr, u.LocalBindPort)
	l.FilterChains = []listener.FilterChain{
		{
			Filters: []listener.Filter{
				makeTCPProxyFilter(u.Identifier(), u.Identifier()),
			},
		},
	}
	return l, nil
}

func makeTCPProxyFilter(name, cluster string) listener.Filter {
	cfg := &tcp.TcpProxy{
		StatPrefix: name,
		Cluster:    cluster,
	}
	return makeFilter("envoy.tcp_proxy", cfg)
}

func makeExtAuthFilter(token string) listener.Filter {
	cfg := &extAuthz.ExtAuthz{
		StatPrefix: "connect_authz",
		GrpcService: &core.GrpcService{
			// Attach token header so we can authorize the callbacks. Technically
			// authorize is not really protected data but we locked down the HTTP
			// implementation to need service:write and since we have the token that
			// has that it's pretty reasonable to set it up here.
			InitialMetadata: []*core.HeaderValue{
				&core.HeaderValue{
					Key:   "x-consul-token",
					Value: token,
				},
			},
			TargetSpecifier: &core.GrpcService_EnvoyGrpc_{
				EnvoyGrpc: &core.GrpcService_EnvoyGrpc{
					ClusterName: LocalAgentClusterName,
				},
			},
		},
		FailureModeAllow: false,
	}
	return makeFilter("envoy.ext_authz", cfg)
}

func makeFilter(name string, cfg proto.Message) listener.Filter {
	// Ridiculous dance to make that pbstruct into types.Struct by... encoding it
	// as JSON and decoding again!!
	cfgStruct, err := util.MessageToStruct(cfg)
	if err != nil {
		panic(err)
	}

	return listener.Filter{
		Name:   name,
		Config: cfgStruct,
	}
}

func makeCommonTLSContext(cfgSnap *proxycfg.ConfigSnapshot) *auth.CommonTlsContext {
	// Concatenate all the root pems into one.
	// TODO(banks): verify this actually works with Envoy (docs are not clear).
	rootPEMS := ""
	for _, root := range cfgSnap.Roots.Roots {
		rootPEMS += root.RootCert
	}

	return &auth.CommonTlsContext{
		TlsParams: &auth.TlsParameters{},
		TlsCertificates: []*auth.TlsCertificate{
			&auth.TlsCertificate{
				CertificateChain: &core.DataSource{
					Specifier: &core.DataSource_InlineString{
						InlineString: cfgSnap.Leaf.CertPEM,
					},
				},
				PrivateKey: &core.DataSource{
					Specifier: &core.DataSource_InlineString{
						InlineString: cfgSnap.Leaf.PrivateKeyPEM,
					},
				},
			},
		},
		ValidationContextType: &auth.CommonTlsContext_ValidationContext{
			ValidationContext: &auth.CertificateValidationContext{
				// TODO(banks): later for L7 support we may need to configure ALPN here.
				TrustedCa: &core.DataSource{
					Specifier: &core.DataSource_InlineString{
						InlineString: rootPEMS,
					},
				},
			},
		},
	}
}
